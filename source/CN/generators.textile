h2. Rails生成器及模板的创建与定制 

如果您计划改善工作流程，Rails 生成器 (generators)必不可少。您将通过本指南学到如何创建它们及定制一个现成的。

将为您呈现：

* 学习如何知道您的应用 (application) 中哪些生成器可用
* 使用模板创建生成器
* 学习如何在调用生成器前搜索它们
* 通过创建新的生成器定制您的scaffold
* 通过修改生成器模板定制您的scaffold
* 学习如何使用回退 (fallbacks) 避免覆盖一个庞大的生成器集合。
* 学习如何创建应用模板

endprologue.

NOTE: 本指南针对Rails 3，未涵盖之前的版本

h3. 初体验

当您使用 +rails+ 命令创建一个应用，实际上就是在使用Rails 生成器。而后，您可以通过调用 +rails generate+ 得到一份可用生成器列表：

<shell>
$ rails new myapp
$ cd myapp
$ rails generate
</shell>

您将获得一份完整的Rails原生生成器列表。如果您需要一个生成器的详细描述，例如 helper生成器，您只需这样:

<shell>
$ rails generate helper --help
</shell>

h3. 创建您的首个生成器

从Rails 3.0开始，生成器基于 "Thor":https://github.com/wycats/thor，Thor 提供强大的选项解析功能和一套牛逼的文件操纵API。例如，让我们创建一个生成器来生成 +config/initializers/initializer.rb+ 文件。

首先创建文件 +lib/generators/initializer_generator.rb+ ，其内容如下：

<ruby>
class InitializerGenerator < Rails::Generators::Base
  def create_initializer_file
    create_file "config/initializers/initializer.rb", "# Add initialization content here"
  end
end
</ruby>

NOTE: +create_file+ 方法由 +Thor::Actions+ 提供. 需要了解 +create_file+ 的文档及其他Thor方法敬请移步 "Thor's documentation":http://rdoc.info/github/wycats/thor/master/Thor/Actions.html

我们的新生成器有点单薄：它继承自 +Rails::Generators::Base+ 并仅有一个方法定义。当生成器被调用，每个生成器中的公共方法依照定义的次序执行。最终，我们调用 +create_file+ 方法，将创建一个给定内容给定位置的文件。如果您熟悉Rails 应用的模板API，您将对新的生成器API有宾至如归的感觉。

调用我们的新生成器，您只需:

<shell>
$ rails generate initializer
</shell>

在我们继续前，来看一下我们的全新生成器的描述：

<shell>
$ rails generate initializer --help
</shell>

要是生成器在命名空间下，Rails 一般都能够生成不错的描述，像是 +ActiveRecord::Generators::ModelGenerator+ ，但是像咱们这种特殊情况 (译注：InitializerGenerator在::下) 就不行了。解决这个问题，有两个选择。第一个在我们的生成器里调用 +desc+ ：

<ruby>
class InitializerGenerator < Rails::Generators::Base
  desc "This generator creates an initializer file at config/initializers"
  def create_initializer_file
    create_file "config/initializers/initializer.rb", "# Add initialization content here"
  end
end
</ruby>

现在我们能通过调用 +--help+ 看到新的生成器描述了。第二选择是在生成器同一目录下创建名为+USAGE+的文件。我们下一步就要这样做。


h3.  用生成器创建生成器

生成器自身拥有一个生成器：

<shell>
$ rails generate generator initializer
      create  lib/generators/initializer
      create  lib/generators/initializer/initializer_generator.rb
      create  lib/generators/initializer/USAGE
      create  lib/generators/initializer/templates
</shell>

刚建的生成器如下：

<ruby>
class InitializerGenerator < Rails::Generators::NamedBase
  source_root File.expand_path("../templates", __FILE__)
end
</ruby>

首先，注意我们继承自 +Rails::Generators::NamedBase+ 而不是 +Rails::Generators::Base+ 了。这意味着我们的生成器预期 (expects) 至少一个参数, 这个参数将作为initializer的名字，在我们的代码中作为变量 +name+ 出现。

我们可以通过调用这个新生成器的描述看出来 (别忘了把之前的生成器文件删掉)

<shell>
$ rails generate initializer --help
Usage:
  rails generate initializer NAME [options]
</shell>

我们还看到新的生成器拥有一个名为 +source_root+ 的类方法。这个方法指出我们的生成器模板在存放的位置 (如果有的话)，默认它指向被创建的目录 +lib/generators/initializer/templates+ 。

为了理解生成器模板的意义，让我们创建文件 +lib/generators/initializer/templates/initializer.rb+ ，其内容如下：

<ruby>
# Add initialization content here
</ruby>

现在让我们修改生成器使其被调用时拷贝这个模板：

<ruby>
class InitializerGenerator < Rails::Generators::NamedBase
  source_root File.expand_path("../templates", __FILE__)

  def copy_initializer_file
    copy_file "initializer.rb", "config/initializers/#{file_name}.rb"
  end
end
</ruby>

来执行我们的生成器：

<shell>
$ rails generate initializer core_extensions
</shell>

我们可以看到现在一个名为core_extensions的initializer被创建在 +config/initializers/core_extensions.rb+ ，内容与我们模板中的相同。这意味着 +copy_file+ 方法拷贝了一个我们的原始文件到了给定的目标路径。当我们继承了 +Rails::Generators::NamedBase+ , 方法 +file_name+ 被自动创建。

本指南的 "final section":#9 涵盖了更多生成器可用方法。

h3. 生成器查找

当您运行 +rails generate initializer core_extensions+ Rails 挨个儿引入这些文件直到生成器被发现为止：

<shell>
rails/generators/initializer/initializer_generator.rb
generators/initializer/initializer_generator.rb
rails/generators/initializer_generator.rb
generators/initializer_generator.rb
</shell>

如果没找到生成器您将收到一条错误信息。

INFO: 之前示例中将生成器文件放在应用的 +lib+ 目录下是因为这个目录属于 +$LOAD_PATH+

h3. 定制您的工作流程

Rails 自带的生成器提供足够的可定制性，让您定制脚手架 (scaffolding)。它们在可以在 +config/application.rb+ 中被配置， 以下是默认配置:

<ruby>
config.generators do |g|
  g.orm             :active_record
  g.template_engine :erb
  g.test_framework  :test_unit, :fixture => true
end
</ruby>

在定制工作流程前，一块先看我们的scaffold是什么样的:

<shell>
$ rails generate scaffold User name:string
      invoke  active_record
      create    db/migrate/20091120125558_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/unit/user_test.rb
      create      test/fixtures/users.yml
       route  resources :users
      invoke  scaffold_controller
      create    app/controllers/users_controller.rb
      invoke    erb
      create      app/views/users
      create      app/views/users/index.html.erb
      create      app/views/users/edit.html.erb
      create      app/views/users/show.html.erb
      create      app/views/users/new.html.erb
      create      app/views/users/_form.html.erb
      invoke    test_unit
      create      test/functional/users_controller_test.rb
      invoke    helper
      create      app/helpers/users_helper.rb
      invoke      test_unit
      create        test/unit/helpers/users_helper_test.rb
      invoke  stylesheets
      create    app/assets/stylesheets/scaffold.css
</shell>

对照输出，很容易理解生成器在Rails 3.0及之前的版本是如何工作的。scaffold生成器实际上不生成任何东西，它只调用其它的生成器工作。这样就允许我们 添加、修改、删除 这些调用。例如，scaffold生成器调用scaffold_controller生成器, 从而调用erb、test_unit和helper生成器。从每个生成器的单一职责，它们极易重用，避免了重复代码。

我们的第一个工作流程定制将阻止为scaffolds生成样式表和测试夹具。可以通过修改我们的工作流程config来实现：

<ruby>
config.generators do |g|
  g.orm             :active_record
  g.template_engine :erb
  g.test_framework  :test_unit, :fixture => false
  g.stylesheets     false
end
</ruby>

如果我们要让scaffold生成另一个resource，可以看到样式表和测试夹具没有再被生成。如果您想定制进一步定制scaffold生成器，例如用DataMapper和RSpec 替代 Active Record和TestUnit，只需要添加这两个gem到您应用里，然后配置您的生成器。

示范一下，我们将创建一个新的helper生成器，它可以简单添加一些实例变量reader。首先，我们在rails命名空间下创建一个生成器，以便rails能够搜索到生成器：

<shell>
$ rails generate generator rails/my_helper
</shell>


之后，我们可以从新的生成器里删掉 +templates+ 目录和 +source_root+ 类方法，因为我们不需要它们。现在我们的新生成器看起来就像这样：

<ruby>
class Rails::MyHelperGenerator < Rails::Generators::NamedBase
    def create_helper_file
        create_file "app/helpers/#{file_name}_helper.rb", <<-FILE
            module #{class_name}Helper
            attr_reader :#{plural_name}, :#{plural_name.singularize}
        end
        FILE
    end
end
</ruby>

我们可以试一下新生成器来生成为products (一个resource)一个helper

<shell>
$ rails generate my_helper products
</shell>

它会在 +app/helpers+ 目录下生成一下的helper文件:

<ruby>
module ProductsHelper
  attr_reader :products, :product
end
</ruby>

正是我们期望的那样。现在我们可以再一次通过编辑 +config/application.rb+  指挥scaffold使用我们的新生成器了。

<ruby>
config.generators do |g|
  g.orm             :active_record
  g.template_engine :erb
  g.test_framework  :test_unit, :fixture => false
  g.stylesheets     false
  g.helper          :my_helper
end
</ruby>

调用scaffold生成器就可以看到my_helper起效了：

<shell>
$ rails generate scaffold Post body:text
      [...]
      invoke    my_helper
      create      app/helpers/posts_helper.rb
</shell>

我们可以在输出上提示新生成器替代了Rails默认的。然而有个事儿忘了，还没生成helper的测试呢，我们要重用原来的helper测试生成器。

从Rails 3.0开始，这事由于钩子机制 (hooks concept) 变得很容易了。我们的新helper无需关注特定的测试框架，它可以方便地提供一个hook，测试框架只需实现这个hook就可以兼容。

我们这样可以修改生成器：

<ruby>
class Rails::MyHelperGenerator < Rails::Generators::NamedBase
    def create_helper_file
       create_file "app/helpers/#{file_name}_helper.rb", <<-FILE
           module #{class_name}Helper
               attr_reader :#{plural_name}, :#{plural_name.singularize}
           end
       FILE
    end

    hook_for :test_framework
end
</ruby>

现在，当helper生成器被调用，假设TestUnit被配置为测试框架，它将尝试调用 +Rails::TestUnitGenerator+ 和 +TestUnit::MyHelperGenerator+。由于这些没有被定义，我们可以告诉我们的生成器调用 +TestUnit::Generators::HelperGenerator+ 替代之，因为它是定义的Rails生成器。我们只需要添加：

<ruby>
# Search for :helper instead of :my_helper
hook_for :test_framework, :as => :helper
</ruby>

现在您可以重新运行scaffold生成另一个resource，并且看到它同时生成了测试！

h3. Customizing Your Workflow by Changing Generators Templates

In the step above we simply wanted to add a line to the generated helper, without adding any extra functionality. There is a simpler way to do that, and it's by replacing the templates of already existing generators, in that case +Rails::Generators::HelperGenerator+.

In Rails 3.0 and above, generators don't just look in the source root for templates, they also search for templates in other paths. And one of them is +lib/templates+. Since we want to customize +Rails::Generators::HelperGenerator+, we can do that by simply making a template copy inside +lib/templates/rails/helper+ with the name +helper.rb+. So let's create that file with the following content:

<erb>
module <%= class_name %>Helper
  attr_reader :<%= plural_name %>, <%= plural_name.singularize %>
end
</erb>

and revert the last change in +config/application.rb+:

<ruby>
config.generators do |g|
  g.orm             :active_record
  g.template_engine :erb
  g.test_framework  :test_unit, :fixture => false
  g.stylesheets     false
end
</ruby>

If you generate another resource, you can see that we get exactly the same result! This is useful if you want to customize your scaffold templates and/or layout by just creating +edit.html.erb+, +index.html.erb+ and so on inside +lib/templates/erb/scaffold+.

h3. Adding Generators Fallbacks

One last feature about generators which is quite useful for plugin generators is fallbacks. For example, imagine that you want to add a feature on top of TestUnit like "shoulda":https://github.com/thoughtbot/shoulda does. Since TestUnit already implements all generators required by Rails and shoulda just wants to overwrite part of it, there is no need for shoulda to reimplement some generators again, it can simply tell Rails to use a +TestUnit+ generator if none was found under the +Shoulda+ namespace.

We can easily simulate this behavior by changing our +config/application.rb+ once again:

<ruby>
config.generators do |g|
  g.orm             :active_record
  g.template_engine :erb
  g.test_framework  :shoulda, :fixture => false
  g.stylesheets     false

  # Add a fallback!
  g.fallbacks[:shoulda] = :test_unit
end
</ruby>

Now, if you create a Comment scaffold, you will see that the shoulda generators are being invoked, and at the end, they are just falling back to TestUnit generators:

<shell>
$ rails generate scaffold Comment body:text
      invoke  active_record
      create    db/migrate/20091120151323_create_comments.rb
      create    app/models/comment.rb
      invoke    shoulda
      create      test/unit/comment_test.rb
      create      test/fixtures/comments.yml
       route    resources :comments
      invoke  scaffold_controller
      create    app/controllers/comments_controller.rb
      invoke    erb
      create      app/views/comments
      create      app/views/comments/index.html.erb
      create      app/views/comments/edit.html.erb
      create      app/views/comments/show.html.erb
      create      app/views/comments/new.html.erb
      create      app/views/comments/_form.html.erb
      create      app/views/layouts/comments.html.erb
      invoke    shoulda
      create      test/functional/comments_controller_test.rb
      invoke    my_helper
      create      app/helpers/comments_helper.rb
      invoke      shoulda
      create        test/unit/helpers/comments_helper_test.rb
</shell>

Fallbacks allow your generators to have a single responsibility, increasing code reuse and reducing the amount of duplication.

h3. Application Templates

Now that you've seen how generators can be used _inside_ an application, did you know they can also be used to _generate_ applications too? This kind of generator is referred as a "template".

<ruby>
gem("rspec-rails", :group => "test")
gem("cucumber-rails", :group => "test")

if yes?("Would you like to install Devise?")
  gem("devise")
  generate("devise:install")
  model_name = ask("What would you like the user model to be called? [user]")
  model_name = "user" if model_name.blank?
  generate("devise", model_name)
end
</ruby>

In the above template we specify that the application relies on the +rspec-rails+ and +cucumber-rails+ gem so these two will be added to the +test+ group in the +Gemfile+. Then we pose a question to the user about whether or not they would like to install Devise. If the user replies "y" or "yes" to this question, then the template will add Devise to the +Gemfile+ outside of any group and then runs the +devise:install+ generator. This template then takes the users input and runs the +devise+ generator, with the user's answer from the last question being passed to this generator.

Imagine that this template was in a file called +template.rb+. We can use it to modify the outcome of the +rails new+ command by using the +-m+ option and passing in the filename:

<shell>
$ rails new thud -m template.rb
</shell>

This command will generate the +Thud+ application, and then apply the template to the generated output.

Templates don't have to be stored on the local system, the +-m+ option also supports online templates:

<shell>
$ rails new thud -m https://gist.github.com/722911.txt
</shell>

Whilst the final section of this guide doesn't cover how to generate the most awesome template known to man, it will take you through the methods available at your disposal so that you can develop it yourself. These same methods are also available for generators.

h3. Generator methods

The following are methods available for both generators and templates for Rails.

NOTE: Methods provided by Thor are not covered this guide and can be found in "Thor's documentation":http://rdoc.info/github/wycats/thor/master/Thor/Actions.html

h4. +gem+

Specifies a gem dependency of the application.

<ruby>
gem("rspec", :group => "test", :version => "2.1.0")
gem("devise", "1.1.5")
</ruby>

Available options are:

* +:group+ - The group in the +Gemfile+ where this gem should go.
* +:version+ - The version string of the gem you want to use. Can also be specified as the second argument to the method.
* +:git+ - The URL to the git repository for this gem.

Any additional options passed to this method are put on the end of the line:

<ruby>
gem("devise", :git => "git://github.com/plataformatec/devise", :branch => "master")
</ruby>

The above code will put the following line into +Gemfile+:

<ruby>
gem "devise", :git => "git://github.com/plataformatec/devise", :branch => "master"
</ruby>

h4. +gem_group+

Wraps gem entries inside a group:

<ruby>
gem_group :development, :test do
  gem "rspec-rails"
end
</ruby>

h4. +add_source+

Adds a specified source to +Gemfile+:

<ruby>
add_source "http://gems.github.com"
</ruby>

h4. +application+

Adds a line to +config/application.rb+ directly after the application class definition.

<ruby>
application "config.asset_host = 'http://example.com'"
</ruby>

This method can also take a block:

<ruby>
application do
  "config.asset_host = 'http://example.com'"
end
</ruby>

Available options are:

* +:env+ - Specify an environment for this configuration option. If you wish to use this option with the block syntax the recommended syntax is as follows:

<ruby>
application(nil, :env => "development") do
  "config.asset_host = 'http://localhost:3000'"
end
</ruby>

h4. +git+

Runs the specified git command:

<ruby>
git :init
git :add => "."
git :commit => "-m First commit!"
git :add => "onefile.rb", :rm => "badfile.cxx"
</ruby>

The values of the hash here being the arguments or options passed to the specific git command. As per the final example shown here, multiple git commands can be specified at a time, but the order of their running is not guaranteed to be the same as the order that they were specified in.

h4. +vendor+

Places a file into +vendor+ which contains the specified code.

<ruby>
vendor("sekrit.rb", '#top secret stuff')
</ruby>

This method also takes a block:

<ruby>
vendor("seeds.rb") do
  "puts 'in ur app, seeding ur database'"
end
</ruby>

h4. +lib+

Places a file into +lib+ which contains the specified code.

<ruby>
lib("special.rb", 'p Rails.root')
</ruby>

This method also takes a block:

<ruby>
lib("super_special.rb") do
  puts "Super special!"
end
</ruby>

h4. +rakefile+

Creates a Rake file in the +lib/tasks+ directory of the application.

<ruby>
rakefile("test.rake", 'hello there')
</ruby>

This method also takes a block:

<ruby>
rakefile("test.rake") do
  %Q{
    task :rock => :environment do
      puts "Rockin'"
    end
  }
end
</ruby>

h4. +initializer+

Creates an initializer in the +config/initializers+ directory of the application:

<ruby>
initializer("begin.rb", "puts 'this is the beginning'")
</ruby>

This method also takes a block:

<ruby>
initializer("begin.rb") do
  puts "Almost done!"
end
</ruby>

h4. +generate+

Runs the specified generator where the first argument is the generator name and the remaining arguments are passed directly to the generator.

<ruby>
generate("scaffold", "forums title:string description:text")
</ruby>


h4. +rake+

Runs the specified Rake task.

<ruby>
rake("db:migrate")
</ruby>

Available options are:

* +:env+ - Specifies the environment in which to run this rake task.
* +:sudo+ - Whether or not to run this task using +sudo+. Defaults to +false+.

h4. +capify!+

Runs the +capify+ command from Capistrano at the root of the application which generates Capistrano configuration.

<ruby>
capify!
</ruby>

h4. +route+

Adds text to the +config/routes.rb+ file:

<ruby>
route("resources :people")
</ruby>

h4. +readme+

Output the contents of a file in the template's +source_path+, usually a README.

<ruby>
readme("README")
</ruby>
